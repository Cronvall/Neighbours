Index: Neighbours/src/Neighbours.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import List\nfrom enum import Enum, auto\nfrom random import *\n\nimport pygame as pg\n\n#test\n\n#  Program to simulate segregation.\n#  See : http:#nifty.stanford.edu/2014/mccown-schelling-model-segregation/\n#\n\n# Enumeration type for the Actors\nclass Actor(Enum):\n    BLUE = auto()\n    RED = auto()\n    NONE = auto()  # NONE used for empty locations\n\n\n# Enumeration type for the state of an Actor\nclass State(Enum):\n    UNSATISFIED = auto()\n    SATISFIED = auto()\n    NA = auto()  # Not applicable (NA), used for NONEs\n\n\nWorld = List[List[Actor]]  # Type alias\n\n\nSIZE = 30\n\n\ndef neighbours():\n    pg.init()\n    model = NeighborsModel(SIZE)\n    _view = NeighboursView(model)\n    model.run()\n\n\nclass NeighborsModel:\n\n    # Tune these numbers to test different distributions or update speeds\n    FRAME_RATE = 20            # Increase number to speed simulation up\n    DIST = [0.25, 0.25, 0.50]  # % of RED, BLUE, and NONE\n    THRESHOLD = 0.7            # % of surrounding neighbours that should be like me for satisfaction\n\n    # ########### These following two methods are what you're supposed to implement  ###########\n    # In this method you should generate a new world\n    # using randomization according to the given arguments.\n    @staticmethod\n    def __create_world(size) -> World:\n        # TODO Create and populate world according to self.DIST distribution parameters\n        brave_new_world = []\n        return brave_new_world\n\n    # This is the method called by the timer to update the world\n    # (i.e move unsatisfied) each \"frame\".\n    def __update_world(self):\n        # TODO Update logical state of world based on self.THRESHOLD satisfaction parameter\n        pass\n\n    # ########### the rest of this class is already defined, to handle the simulation clock  ###########\n    def __init__(self, size):\n        self.world: World = self.__create_world(size)\n        self.observers = []  # for enabling discoupled updating of the view, ignore\n\n    def run(self):\n        clock = pg.time.Clock()\n        running = True\n        while running:\n            running = self.__on_clock_tick(clock)\n        # stop running\n        print(\"Goodbye!\")\n        pg.quit()\n\n    def __on_clock_tick(self, clock):\n        clock.tick(self.FRAME_RATE)  # update no faster than FRAME_RATE times per second\n        self.__update_and_notify()\n        return self.__check_for_exit()\n\n    # What to do each frame\n    def __update_and_notify(self):\n        self.__update_world()\n        self.__notify_all()\n\n    @staticmethod\n    def __check_for_exit() -> bool:\n        keep_going = True\n        for event in pg.event.get():\n            # Did the user click the window close button?\n            if event.type == pg.QUIT:\n                keep_going = False\n        return keep_going\n\n    # Use an Observer pattern for views\n    def add_observer(self, observer):\n        self.observers.append(observer)\n\n    def __notify_all(self):\n        for observer in self.observers:\n            observer.on_world_update()\n\n\n# ---------------- Helper methods ---------------------\n\n# Check if inside world\ndef is_valid_location(size: int, row: int, col: int):\n    return 0 <= row < size and 0 <= col < size\n\n\n# ------- Testing -------------------------------------\n\n# Here you run your tests i.e. call your logic methods\n# to see that they really work\ndef test():\n    # A small hard coded world for testing\n    test_world = [\n        [Actor.RED, Actor.RED, Actor.NONE],\n        [Actor.NONE, Actor.BLUE, Actor.NONE],\n        [Actor.RED, Actor.NONE, Actor.BLUE]\n    ]\n\n    th = 0.5  # Simpler threshold used for testing\n\n    size = len(test_world)\n    print(is_valid_location(size, 0, 0))\n    print(not is_valid_location(size, -1, 0))\n    print(not is_valid_location(size, 0, 3))\n    print(is_valid_location(size, 2, 2))\n\n    # TODO More tests\n\n    exit(0)\n\n\n# Helper method for testing\ndef count(a_list, to_find):\n    the_count = 0\n    for a in a_list:\n        if a == to_find:\n            the_count += 1\n    return the_count\n\n\n# ###########  NOTHING to do below this row, it's pygame display stuff  ###########\n# ... but by all means have a look at it, it's fun!\nclass NeighboursView:\n    # static class variables\n    WIDTH = 400   # Size for window\n    HEIGHT = 400\n    MARGIN = 50\n\n    WHITE = (255, 255, 255)\n    RED   = (255,   0,   0)\n    BLUE  = (  0,   0, 255)\n\n    # Instance methods\n\n    def __init__(self, model: NeighborsModel):\n        pg.init()  # initialize pygame, in case not already done\n        self.dot_size = self.__calculate_dot_size(len(model.world))\n        self.screen = pg.display.set_mode([self.WIDTH, self.HEIGHT])\n        self.model = model\n        self.model.add_observer(self)\n\n    def render_world(self):\n        # # Render the state of the world to the screen\n        self.__draw_background()\n        self.__draw_all_actors()\n        self.__update_screen()\n\n    # Needed for observer pattern\n    # What do we do every time we're told the model had been updated?\n    def on_world_update(self):\n        self.render_world()\n\n    # private helper methods\n    def __calculate_dot_size(self, size):\n        return max((self.WIDTH - 2 * self.MARGIN) / size, 2)\n\n    @staticmethod\n    def __update_screen():\n        pg.display.flip()\n\n    def __draw_background(self):\n        self.screen.fill(NeighboursView.WHITE)\n\n    def __draw_all_actors(self):\n        for row in range(len(self.model.world)):\n            for col in range(len(self.model.world[row])):\n                self.__draw_actor_at(col, row)\n\n    def __draw_actor_at(self, col, row):\n        color = self.__get_color(self.model.world[row][col])\n        xy = self.__calculate_coordinates(col, row)\n        pg.draw.circle(self.screen, color, xy, self.dot_size / 2)\n\n    # This method showcases how to nicely emulate 'switch'-statements in python\n    @staticmethod\n    def __get_color(actor):\n        return {\n            Actor.RED: NeighboursView.RED,\n            Actor.BLUE: NeighboursView.BLUE\n        }.get(actor, NeighboursView.WHITE)\n\n    def __calculate_coordinates(self, col, row):\n        x = self.__calculate_coordinate(col)\n        y = self.__calculate_coordinate(row)\n        return x, y\n\n    def __calculate_coordinate(self, offset):\n        x: float = self.dot_size * offset + self.MARGIN\n        return x\n\n\nif __name__ == \"__main__\":\n    test()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Neighbours/src/Neighbours.py b/Neighbours/src/Neighbours.py
--- a/Neighbours/src/Neighbours.py	(revision df85eff2ea7b4d23c31d0d59679407d90b8b73b3)
+++ b/Neighbours/src/Neighbours.py	(date 1631709089437)
@@ -4,7 +4,6 @@
 
 import pygame as pg
 
-#test
 
 #  Program to simulate segregation.
 #  See : http:#nifty.stanford.edu/2014/mccown-schelling-model-segregation/
